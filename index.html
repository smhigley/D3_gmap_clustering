<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
    <style type="text/css">

html, body, #map {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

.stations, .stations svg {
  position: absolute;
}

.stations svg {
  font: 10px sans-serif;
}

.stations circle {
  fill: #55CADB;
  stroke: rgba(85,202,219,0.5);
  stroke-width: 5px;
}

    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="data"></div>
    <script type="text/javascript">

$(function(){

  var cur_zoom = 7;

  // Load the station data. When the data comes back, create an overlay.
  var map = new google.maps.Map(d3.select("#map").node(), {
    zoom: cur_zoom,
    center: new google.maps.LatLng(30.331227, -97.725019),
    mapTypeId: google.maps.MapTypeId.TERRAIN
  });

  //test data file
  file = 'clusters.json';
  raw_data = 'data.json';

  //call flickr api
  flickr_api_key = '5f6652a08b32dd50ae264fb3f47a9632';
  flickr_api_secret = '6826da1b61cf3f39';
  //url vars
  tags = 'cat'
  url = 'http://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=' + flickr_api_key + '&tags=' + tags + '&woe_id=2347602&has_geo=1&extras=geo&format=json&nojsoncallback=1&per_page=100';

  //function to caculate dist btw points. Args in format [x, y]
  function coords_dist( point1, point2 ) {
    var xs = 0;
    var ys = 0;

    xs = point2[0] - point1[0];
    xs = xs * xs;

    ys = point2[1] - point1[1];
    ys = ys * ys;

    return Math.sqrt( xs + ys );
  }

  d3.json(file, function(error, data) {
    if (error) return console.warn(error);

    //save full cluster data, then get
    var clusters = data,
        data = clusters[cur_zoom];

    console.log(data);

    var overlay = new google.maps.OverlayView();

    //data = data.photos.photo;

    //set bounds based on data's max lat and long
    var latmax = d3.max(data, function(d){ return d.latitude }),
        latmin = d3.min(data, function(d){ return d.latitude }),
        longmax = d3.max(data, function(d){ return d.longitude }),
        longmin = d3.min(data, function(d){ return d.longitude }),
        southWest = new google.maps.LatLng(latmin, longmin),
        northEast = new google.maps.LatLng(latmax, longmax),
        new_bounds = new google.maps.LatLngBounds(southWest, northEast);

    // map marker radius to values between 6px and 20px
    var marker_radius = d3.scale.linear()
      .domain( d3.extent(data, function(d) { return d.size; }) )
      .range([6, 20]);

    // Add the container when the overlay is added to the map.
    overlay.onAdd = function() {
      map.fitBounds(new_bounds);
      var layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
          .attr("class", "stations");

      // Draw each marker as a separate SVG element.
      // We could use a single SVG, but what size would it have?
      overlay.draw = function() {
        cur_zoom = map.getZoom();
        data = clusters[cur_zoom];

        console.log(cur_zoom);

        var projection = this.getProjection(),
            padding = 10;

        var marker = layer.selectAll("svg")
            //.data(d3.values(data))
            .data(data, function(d) { return d3.values(d); })
            .each(display); // update existing markers

        marker.enter().append("svg:svg")
            .each(display)
            .attr("width", function(d) { return marker_radius(d.size)*2 + padding*2 })
            .attr("height", function(d) { return marker_radius(d.size)*2 + padding*2 })
            .attr("class", "marker");

        marker.exit()
              .remove();

        // Add a circle.
        marker.append("svg:circle")
            .attr("r", 0)
            .attr("cx", function(d) { return marker_radius(d.size) + padding })
            .attr("cy", function(d) { return marker_radius(d.size) + padding })
            .transition()
            .duration(600)
            .attr("r", function(d) { return marker_radius(d.size); });

        // Add a label.
        marker.append("svg:text")
            .attr("x", function(d) { return marker_radius(d.size) + padding - 3 })
            .attr("y", function(d) { return marker_radius(d.size) + padding })
            .attr("dy", ".31em")
            .text(function(d) { return d.size; });

        function display(d) {
          //console.log(d);
          d = new google.maps.LatLng(d.latitude, d.longitude);
          d = projection.fromLatLngToDivPixel(d);
          //console.log(d3.select(this));
          //console.log("x-pos is " + d.x + " y-pos is " + d.y);
          return d3.select(this)
              .style("left", (d.x - padding) + "px")
              .style("top", (d.y - padding) + "px");
        }

      };
    };

    // Bind overlay to the mapâ€¦
    overlay.setMap(map);
  });
});

    </script>
  </body>
</html>
